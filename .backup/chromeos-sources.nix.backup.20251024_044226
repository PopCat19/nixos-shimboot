{
  self,
  nixpkgs,
  board ? "dedede",
  ...
}: let
  system = "x86_64-linux";
  pkgs = import nixpkgs {
    inherit system;
    config = {
      allowUnfree = true;
      allowUnfreePredicate = pkg:
        builtins.elem (nixpkgs.lib.getName pkg) [
          "chromeos-shim-${board}"
          "chromeos-recovery-${board}"
        ];
    };
  };

  # Import generated manifest from fetch-manifest.sh
  boardManifest = import ../manifests/${board}-manifest.nix;

  chunkBaseUrl = "https://cdn.cros.download/files/${board}";

  # Fetch each chunk as a fixed-output derivation
  chunkDrvs =
    map (
      chunk:
        pkgs.fetchurl {
          url = "${chunkBaseUrl}/${chunk.name}";
          sha256 = chunk.sha256;
          curlOpts = "--retry-delay 10";
        }
    )
    boardManifest.chunks;

  # ChromeOS shim firmware - proprietary binary from Google
  # This derivation downloads and repackages ChromeOS firmware blobs.
  # The output remains under Google's proprietary license terms and is marked unfree.
  chromeosShim = pkgs.stdenv.mkDerivation {
    name = "chromeos-shim-${board}";
    version = board;

    # Fixed-output derivation: Nix knows the final zip hash
    outputHashMode = "flat";
    outputHashAlgo = "sha256";
    outputHash = boardManifest.hash;

    nativeBuildInputs = [pkgs.unzip];

    buildCommand = ''
      echo "Joining ${toString (builtins.length boardManifest.chunks)} chunks for ${board}..."
      cat ${pkgs.lib.concatStringsSep " " chunkDrvs} > ${board}.zip

      echo "Extracting shim.bin..."
      unzip -p ${board}.zip > $out
    '';

    meta = with pkgs.lib; {
      description = "ChromeOS shim firmware for ${board} board";
      longDescription = ''
        Downloads and extracts the ChromeOS shim firmware for the ${board} board
        from the official ChromeOS CDN, using the manifest + chunk method.
      '';
      license = licenses.unfree;
      platforms = platforms.linux;
      maintainers = ["shimboot developers"];
    };
  };

  # ChromeOS recovery firmware - proprietary binary from Google
  # This derivation downloads and extracts ChromeOS recovery images.
  # The output remains under Google's proprietary license terms and is marked unfree.
  chromeosRecovery = let
    recoveryUrls = {
      corsola = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_corsola_recovery_stable-channel_CorsolaMPKeys-v22.bin.zip";
        sha256 = "sha256-7344c35826d14cebea56e684ac0ca98741a2c452";
      };
      dedede = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_13597.105.0_dedede_recovery_stable-channel_mp-v3.bin.zip";
        sha256 = "sha256-4YNU6qHF/LF/znVJ1pOJpI+NJYB/B/TGGMaHM5uyJhQ=";
      };
      grunt = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_grunt_recovery_stable-channel_GruntMPKeys-v12.bin.zip";
        sha256 = "sha256-78e88a6c9b67c4c4be7a33b0918dc5277442a084";
      };
      hana = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16267.66.0_hana_recovery_stable-channel_HanaMPKeys-v13.bin.zip";
        sha256 = "sha256-9dae67849552e8b2c8222b2a773e523928230199";
      };
      hatch = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_hatch_recovery_stable-channel_HatchMPKeys-v12.bin.zip";
        sha256 = "sha256-be162c8704b0bb32afabf2c92358c73e3a3ed71c";
      };
      jacuzzi = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_jacuzzi_recovery_stable-channel_JacuzziMPKeys-v19.bin.zip";
        sha256 = "sha256-746ef07d2d4be0e35f07a27af40aa43ac1e896aa";
      };
      nissa = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_nissa_recovery_stable-channel_NissaMPKeys-v58.bin.zip";
        sha256 = "sha256-c2d180a1f1beb3983a5e74e680d5e638df6caf69";
      };
      octopus = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_11316.165.0_octopus_recovery_stable-channel_mp-v5.bin.zip";
        sha256 = "sha256-wZS7P8Ad2xYTPb8RtT4YiH9SXGCclped/nls+Y+XCRQ=";
      };
      snappy = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_15886.44.0_snappy_recovery_stable-channel_mp-v4.bin.zip";
        sha256 = "sha256-2624f494b5ce53a5ad198650ace242173364da58";
      };
      zork = {
        url = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_16404.45.0_zork_recovery_stable-channel_ZorkMPKeys-v13.bin.zip";
        sha256 = "sha256-55ba123e9dc1e03169db4e9767ef7be1850518f4";
      };
    };
    recoveryData = recoveryUrls.${board} or (throw "Unsupported board: ${board}");
  in
  pkgs.stdenv.mkDerivation {
    name = "chromeos-recovery-${board}";
    version = "${board}";

    src = pkgs.fetchurl {
      inherit (recoveryData) url sha256;
    };

    nativeBuildInputs = [pkgs.unzip];

    unpackPhase = ''
      runHook preUnpack
      echo "Unpacking ChromeOS recovery image..."
      unzip $src
      runHook postUnpack
    '';

    installPhase = ''
      runHook preInstall
      mkdir -p $out
      echo "Searching for recovery binary..."
      for file in $(find . -type f); do
        file_size=$(stat -c%s "$file")
        if [ $file_size -gt 1000000 ]; then
          echo "Installing $file as recovery.bin"
          cp "$file" $out/recovery.bin
          break
        fi
      done
      if [ ! -f "$out/recovery.bin" ]; then
        echo "ERROR: Could not find recovery binary"
        exit 1
      fi
      echo "Installed recovery.bin ($(stat -c%s $out/recovery.bin) bytes)"
      runHook postInstall
    '';

    meta = with pkgs.lib; {
      description = "ChromeOS recovery firmware for ${board} board";
      license = licenses.unfree;
      platforms = platforms.linux;
      maintainers = ["shimboot developers"];
    };
  };
in {
  packages.${system} = {
    "chromeos-shim-${board}" = chromeosShim;
    "chromeos-recovery-${board}" = chromeosRecovery;
  };
}
